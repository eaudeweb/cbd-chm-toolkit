<?php
/**
 * @file
 * Code for the chm_export feature.
 */

/**
 * Implements hook_views_api().
 */
function chm_export_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'chm_export') . '/views',
  );
}

function _chm_export_entity_as_json($entity, $id, $type) {
  global $base_url;
  if (!$entity) {
    drupal_not_found();
    return;
  }
  $data = array(
    'uuid' => $entity->uuid,
  );

  if ($type == 'node') {
    $data['changed'] = $entity->changed;
  }

  $bundle_name = ($type == 'node') ? $entity->type : $entity->vocabulary_machine_name;
  $fields = field_info_instances($type, $bundle_name);
  $w = entity_metadata_wrapper($type, $entity);
  foreach (array_keys($fields) as $field_name) {
    $res_field_name = str_replace(['field_', '_field'], ['', ''], $field_name);
    $info = field_info_field($field_name);
    if ($field_name == 'field_files') {
      $files = array();
      if (!empty($entity->{$field_name})) {
        foreach ($entity->{$field_name} as $lang => $lang_files) {
          foreach($lang_files as $item) {
            $files[] = array(
              'filename' => $item['filename'],
              'url' => file_create_url($item['uri']),
            );
          }
        }
      }
      $data[$res_field_name] = $files;
      continue;
    }
    if ($field_name == 'field_sorting_date') {
      foreach ($entity->{$field_name}[LANGUAGE_NONE] as $key => $element) {
        unset($element['db']);
        $entity->{$field_name}[LANGUAGE_NONE][$key] = $element;
      }
    }
    if ($info['type'] == 'entityreference') {
      $data[$field_name] = array();
      if ($field_name == 'field_country') {
        foreach ($entity->{$field_name}[LANGUAGE_NONE] as $element) {
          $country = node_load($element['target_id']);
          $country_code = $country->field_country_iso3[LANGUAGE_NONE][0]['value'];
          $data[$res_field_name][] = $country_code;
        }
      }
      elseif (in_array($field_name, array('field_treaty', 'field_faolex_reference'))) {
        foreach ($entity->{$field_name}[LANGUAGE_NONE] as $element) {
          $target = node_load($element['target_id']);
          $original_id = !empty($target->field_original_id) ? $target->field_original_id[LANGUAGE_NONE][0]['value'] : NULL;
          $data[$res_field_name][] = array(
            'uuid' => $target->uuid,
            'url' => url(drupal_get_path_alias('uuid/node/' . $target->uuid), array('absolute' => TRUE)),
            'original_id' => $original_id,
          );
        }
      }
      else {
        if ($entity->{$field_name}) {
          foreach ($entity->{$field_name}[LANGUAGE_NONE] as $element) {
            $target = node_load($element['target_id']);
            $data[$res_field_name][] = array(
              'uuid' => $target->uuid,
              'url' => url(drupal_get_path_alias('uuid/node/' . $target->uuid), array('absolute' => TRUE)),
            );
          }
        }
      }
      continue;
    }
    if ($info['type'] == 'taxonomy_term_reference') {
      $terms = array();
      $values = $w->$field_name->value();
      if (is_array($values)) {
        if (!empty($values)) {
          foreach ($values as $key => $value) {
            $terms[$key] = (object) array(
              'label' => $value->name,
              'url' => url(drupal_get_path_alias('taxonomy/term/' . $value->tid), array('absolute' => TRUE)),
            );
          }
          $data[$res_field_name] = $terms;
          continue;
        }
      }
      elseif ($values != NULL) {
        $terms = array();
        $terms[0] = (object) array(
          'id' => $values->tid,
          'url' => url('taxonomy/term/' . $values->tid, array('absolute' => TRUE)),
          'label' => $values->name,
        );
        $data[$res_field_name] = $terms;
        continue;
      }
      else {
        $data[$res_field_name] = array();
      }
    }

    $data[$res_field_name] = $entity->{$field_name};
  }
  unset($data['field_data_source']);
  if ($type == 'node') {
    $aliases = array('default' => $base_url . '/node/' . $id);
    foreach (language_list() as $code => $language) {
      $aliases[$code] = url('node/' . $id, array('absolute' => TRUE, 'language' => $language));
    }
    $data['url'] = $aliases;
  }
  if ($type != 'node') {
    $aliases = array('default' => $base_url . '/taxonomy/term/' . $id);
    foreach (language_list() as $code => $language) {
      $aliases[$code] = url('taxonomy/term/' . $id, array('absolute' => TRUE, 'language' => $language));
    }
    $data['url'] = $aliases;
  }
  return $data;
}

/**
 * Encodes JSON in a pretty-printed fashion.
 *
 * @deprecated The $option parameter in PHP 5.4.0 json_encode() deprecates this function.
 *
 * @see _views_json_json_encode
 */
function _chm_export_encode_formatted($v, $options, $depth = 0) {
  $base_indent = '&nbsp;&nbsp;';
  $eol = '<br />';
  $indent = str_repeat($base_indent, $depth);

  // This is based on the drupal_to_js() function.
  switch (gettype($v)) {
    case 'boolean':
      // Lowercase is necessary!
      return $v ? 'true' : 'false';

    case 'integer':
    case 'double':
      return $v;

    case 'resource':
    case 'string':
      $search = array(
        '"',
        chr(92),
        chr(8),
        chr(12),
        chr(13) . chr(10),
        chr(10),
        chr(13),
        chr(9)
      );
      $replace = array('\"', '\\', '\b', '\f', '\n', '\n', '\r', '\t');
      $output = str_replace($search, $replace, $v);

      // Convert string to numeric if need.
      if (!empty($options['numeric_strings']) && is_numeric($output)) {
        return (strpos($output, '.') !== FALSE) ? floatval($output) : intval($output);
      }
      /* *
            $output = str_replace(array("\r", "\n", "<", ">", "&"),
                                 array('\r', '\n', '\x3c', '\x3e', '\x26'),
                                 addslashes($output));
      /* */
      return '"' . check_plain($output) . '"';

    case 'array':
      // Arrays in JSON can't be associative.  If the array is empty or if it
      // has sequential whole number keys starting with 0, it's not associative
      // so we can go ahead and convert it as an array.
      if (empty($v) || array_keys($v) === range(0, sizeof($v) - 1)) {
        $output = array();
        foreach ($v as $val) {
          $output[] = $indent . $base_indent . _chm_export_encode_formatted($val, $options, $depth + 1);
        }
        return '[' . (!empty($output) ? $eol . implode(',' . $eol, $output) . $eol . $indent : '') . ']';
      }
    // Otherwise, fall through to convert the array as an object.

    case 'object':
      $output = array();
      foreach ($v as $key => $val) {
        $output[] = $indent . $base_indent . _chm_export_encode_formatted(strval($key), $options) . ' : ' . _chm_export_encode_formatted($val, $options, $depth + 1);
      }
      return '{' . (!empty($output) ? $eol . implode(',' . $eol, $output) . $eol . $indent : '') . '}';

    default:
      return 'null';
  }
}

/**
 * Takes each field from a row object and renders the field as determined by the field's theme
 *
 * @param $view
 *   View the row belongs to
 * @param $row
 *   Row object
 * @return array
 *   Object containing all the raw and rendered fields
 */
function _chm_export_render_fields($view, $row) {
  $entity = NULL;
  $id = NULL;
  $type = NULL;
  if (property_exists($row, 'tid')) {
    $id = $row->tid;
    $type = 'taxonomy_term';
    $entity = taxonomy_term_load($row->tid);
  }
  if (property_exists($row, 'nid')) {
    $id = $row->nid;
    $type = 'node';
    $entity = node_load($row->nid);
  }

  $rendered_fields = _chm_export_entity_as_json($entity, $id, $type);
  return $rendered_fields;
}

/**
 * Backwards-compatible JSON encoder.
 *
 * Provides backwars-compatible support for more JSON encoding formats.
 * Uses PHP's native JSON encoding when PHP 5.3.0 or greater is detected.
 * Fallbacks to manual encoding/escaping when PHP 5.2.x and below is detected.
 *
 * @param array $rows
 *   Results from template_preprocess_views_chm_export_style_simple().
 * @param int $bitmask
 *   Integer to use as the $bitmask parameter for json_encode().
 */
function _chm_export_json_encode($rows, $bitmask = NULL) {
  if(defined('PHP_MAJOR_VERSION') && PHP_MAJOR_VERSION >= 5 && PHP_MINOR_VERSION >= 3) {
    $json = json_encode($rows, $bitmask);
    // Encoding features not supported before 5.4.x.
    if (PHP_MINOR_VERSION <= 4) {
      $json = str_replace(array('\/'), array('/'), $json);
    }
  }
  // For php 5.2 and below
  else {
    $json = json_encode($rows);
    // Fix for issue #1613344.
    $json = str_replace(array('\/'), array('/'), $json);
  }
  return $json;
}
